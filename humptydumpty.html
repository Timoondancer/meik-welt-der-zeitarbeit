<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Humpty Dumpty Run ¬∑ TIMEPARTNER</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700;800;900&family=Nunito+Sans:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    :root {
      --tp-blue:#0b2d42;
      --tp-blue-2:rgba(18,58,87,0.96);
      --tp-green:#b6de36;
      --tp-muted:#6f8a9b;
      --tp-border:#dfe6ea;
      --radius:14px;
      --shadow:0 10px 26px rgba(11,45,66,.14);
      --focus:rgba(182,222,54,.25);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
    }

    body {
      font-family: "Nunito Sans", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #02101a url("assets/img/hintergrund.png") center/cover no-repeat fixed;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .backdrop {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, rgba(11,45,66,0.25), rgba(2,10,18,0.9));
      pointer-events: none;
      z-index: -1;
    }

    .game-shell {
      width: 100%;
      max-width: 1100px;
      background: rgba(11,45,66,0.96);
      border-radius: 24px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,0.06);
      padding: 24px 24px 28px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .game-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .title-block h1 {
      font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-weight: 800;
      font-size: clamp(1.5rem, 1.1rem + 1vw, 2rem);
      letter-spacing: .03em;
      text-transform: uppercase;
    }

    .title-block p {
      margin-top: 2px;
      font-size: 0.9rem;
      color: var(--tp-muted);
    }

    .control-hint {
      font-size: 0.85rem;
      color: var(--tp-muted);
      text-align: right;
    }

    .control-hint span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(2,10,18,0.3);
      font-size: 0.8rem;
    }

    .control-hint kbd {
      font-family: "Nunito Sans", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 0.75rem;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(0,0,0,0.35);
    }

    .game-card {
      background: radial-gradient(circle at top left, rgba(182,222,54,0.10), rgba(1,7,12,0.95));
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.06);
      padding: 18px 18px 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .hud {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.9rem;
      color: #e4edf3;
      gap: 12px;
    }

    .hud-left {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(3,15,26,0.9);
      font-size: 0.8rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .pill-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--tp-green);
      box-shadow: 0 0 0 4px rgba(182,222,54,0.18);
    }

    .pill-label {
      color: var(--tp-muted);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: .08em;
    }

    .pill-value {
      font-weight: 700;
      color: var(--tp-green);
      font-variant-numeric: tabular-nums;
    }

    .hud-right {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .hud-right .pill-value {
      color: #fff;
    }

    canvas {
      width: 100%;
      max-width: 100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.05);
      background: #6fd6ff; /* fallback */
      display: block;
      margin: 0 auto;
      touch-action: manipulation;
    }

    .game-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem;
      color: var(--tp-muted);
      margin-top: 4px;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tp-btn-primary,
    .tp-btn-ghost {
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: .02em;
      text-transform: uppercase;
      border: 1px solid transparent;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-family: "Nunito Sans", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, border-color 0.12s ease;
    }

    .tp-btn-primary {
      background: linear-gradient(135deg, var(--tp-green), #d7ff6e);
      color: #091314;
      box-shadow: 0 10px 26px rgba(182,222,54,.35);
    }

    .tp-btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(182,222,54,.45);
    }

    .tp-btn-primary:active {
      transform: translateY(0);
      box-shadow: 0 6px 18px rgba(182,222,54,.35);
    }

    .tp-btn-ghost {
      background: transparent;
      border-color: rgba(255,255,255,0.18);
      color: #e1ecf3;
    }

    .tp-btn-ghost:hover {
      background: rgba(2,15,26,0.65);
      transform: translateY(-1px);
    }

    .tp-btn-ghost:active {
      transform: translateY(0);
      background: rgba(2,15,26,0.9);
    }

    .footer-links {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
      align-items: center;
    }

    .footer-links a {
      color: var(--tp-green);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.8rem;
    }

    .footer-links a:hover {
      text-decoration: underline;
    }

    @media (max-width: 640px) {
      body {
        padding: 16px;
      }

      .game-shell {
        padding: 18px 16px 20px;
      }

      .hud {
        flex-direction: column;
        align-items: flex-start;
      }

      .game-header {
        align-items: flex-start;
      }

      .control-hint {
        text-align: left;
      }
    }
  </style>
</head>
<body>
  <div class="backdrop"></div>

  <main class="game-shell" aria-label="Humpty Dumpty Jump Game">
    <header class="game-header">
      <div class="title-block">
        <h1>Humpty Dumpty Run</h1>
        <p>Bunte 90s-Pok√©mon-Vibes f√ºr Kids ‚Äì springe √ºber Mauern, bis du 100.000 Punkte erreichst.</p>
      </div>
      <div class="control-hint">
        <span>
          <kbd>Leertaste</kbd> oder Tippen ¬∑ zum Springen
        </span>
      </div>
    </header>

    <section class="game-card">
      <div class="hud">
        <div class="hud-left">
          <div class="pill">
            <div class="pill-dot"></div>
            <span class="pill-label">Score</span>
            <span id="score" class="pill-value">0</span>
          </div>
          <div class="pill">
            <span class="pill-label">Ziel</span>
            <span class="pill-value">100.000</span>
          </div>
        </div>
        <div class="hud-right">
          <div class="pill">
            <span class="pill-label">Best</span>
            <span id="highScore" class="pill-value">0</span>
          </div>
          <button id="restartBtn" type="button" class="tp-btn-ghost">
            Neustart
          </button>
        </div>
      </div>

      <canvas id="gameCanvas" width="900" height="260" aria-label="Humpty Dumpty Jump"></canvas>

      <div class="game-footer">
        <div>Spring √ºber Mauern, sammle Punkte ‚Äì aber wenn du f√§llst, wirst du zum Spiegelei. üç≥</div>
        <div class="footer-links">
          <button id="backBtn" type="button" class="tp-btn-primary" onclick="window.location.href='konfigurator.html'">
            Zur√ºck zum Konfigurator
          </button>
        </div>
      </div>
    </section>
  </main>
    <script>
    (function () {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      const scoreEl = document.getElementById("score");
      const highScoreEl = document.getElementById("highScore");
      const restartBtn = document.getElementById("restartBtn");

      const GROUND_Y = canvas.height - 46;
      const HUMPTY_X = 130;

      const targetScore = 100000;

      const state = {
        running: false,
        gameOver: false,
        win: false,
        score: 0,
        highScore: 0,
        speed: 9,          // schneller
        gravity: 0.75,
        spawnTimer: 0,
        spawnInterval: 80, // engere Abst√§nde
        frame: 0
      };

      const humpty = {
        x: HUMPTY_X,
        y: GROUND_Y - 64,
        width: 46,
        height: 64,
        vy: 0,
        jumping: false
      };

      let obstacles = [];

      function initGame() {
        state.running = true;
        state.gameOver = false;
        state.win = false;
        state.score = 0;
        state.speed = 9;
        state.spawnTimer = 0;
        state.spawnInterval = 80;
        state.frame = 0;
        humpty.y = GROUND_Y - humpty.height;
        humpty.vy = 0;
        humpty.jumping = false;
        obstacles = [];
        updateScoreUI();
      }

      function updateScoreUI() {
        scoreEl.textContent = Math.floor(state.score);
        highScoreEl.textContent = Math.floor(state.highScore);
      }

      function spawnObstacle() {
        const height = 34 + Math.random() * 36;
        const width = 22 + Math.random() * 16;

        obstacles.push({
          x: canvas.width + 40,
          y: GROUND_Y - height,
          width: width,
          height: height
        });
      }

      function jump() {
        if (state.gameOver || state.win) {
          initGame();
          return;
        }
        if (!state.running) {
          initGame();
        }
        if (!humpty.jumping) {
          humpty.vy = -14.5;
          humpty.jumping = true;
        }
      }

      function update() {
        if (!state.running) {
          draw();
          requestAnimationFrame(update);
          return;
        }

        state.frame++;

        // Schwierigkeit hoch
        if (state.frame % 320 === 0 && state.speed < 18) {
          state.speed += 0.45;
        }
        if (state.frame % 480 === 0 && state.spawnInterval > 52) {
          state.spawnInterval -= 4;
        }

        // Score
        state.score += 1.8 + state.speed * 0.05;
        if (state.score > state.highScore) {
          state.highScore = state.score;
        }
        updateScoreUI();

        // WIN + Weiterleitung
        if (state.score >= targetScore && !state.win) {
          state.win = true;
          state.running = false;

          // ‚≠ê Weiterleitung nach 2,5 Sekunden
          setTimeout(() => {
            window.location.href = "https://timepartner.com/platzhalter";
          }, 2500);
        }

        // Physik
        humpty.vy += state.gravity;
        humpty.y += humpty.vy;

        if (humpty.y + humpty.height >= GROUND_Y) {
          humpty.y = GROUND_Y - humpty.height;
          humpty.vy = 0;
          humpty.jumping = false;
        }

        // Hindernisse
        state.spawnTimer++;
        if (state.spawnTimer >= state.spawnInterval && !state.win) {
          spawnObstacle();
          state.spawnTimer = 0;
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
          obstacles[i].x -= state.speed;

          if (obstacles[i].x + obstacles[i].width < 0) {
            obstacles.splice(i, 1);
            continue;
          }

          // Kollision
          if (!state.gameOver && !state.win && checkCollision(humpty, obstacles[i])) {
            state.gameOver = true;
            state.running = false;
          }
        }

        draw();
        requestAnimationFrame(update);
      }

      function checkCollision(a, b) {
        return (
          a.x < b.x + b.width &&
          a.x + a.width > b.x &&
          a.y < b.y + b.height &&
          a.y + a.height > b.y
        );
      }

      /* ---------------------------------------------
         CUTE POK√âMON STYLE BACKGROUND (90s Vibes)
      ----------------------------------------------*/
      function drawBackground() {
        // Himmel
        const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        skyGrad.addColorStop(0, "#84e0ff");
        skyGrad.addColorStop(0.45, "#c9f0ff");
        skyGrad.addColorStop(1, "#ffeef8");
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Sonne
        ctx.save();
        ctx.globalAlpha = 0.8;
        const sunX = canvas.width - 90;
        const sunY = 60;
        const sunGrad = ctx.createRadialGradient(sunX, sunY, 8, sunX, sunY, 40);
        sunGrad.addColorStop(0, "#fffad1");
        sunGrad.addColorStop(1, "rgba(255,234,138,0)");
        ctx.fillStyle = sunGrad;
        ctx.beginPath();
        ctx.arc(sunX, sunY, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Wolken
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        const cloudBaseY1 = 44;
        const cloudBaseY2 = 78;
        const cloudOffset = (state.frame * 0.6) % (canvas.width + 200);

        drawCloud(cloudOffset - 260, cloudBaseY1, 42);
        drawCloud(cloudOffset - 120, cloudBaseY2, 32);
        drawCloud(cloudOffset + 60, cloudBaseY1 + 6, 38);
        drawCloud(cloudOffset + 220, cloudBaseY2 + 4, 30);
        ctx.restore();

        // H√ºgel hinten
        ctx.save();
        const hillGradBack = ctx.createLinearGradient(0, GROUND_Y - 80, 0, canvas.height);
        hillGradBack.addColorStop(0, "#b3f5d2");
        hillGradBack.addColorStop(1, "#7ad37c");
        ctx.fillStyle = hillGradBack;
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y - 10);
        for (let x = 0; x <= canvas.width; x += 30) {
          const y = GROUND_Y - 10 - Math.sin((x + state.frame * 0.03) / 40) * 8;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.fill();
        ctx.restore();

        // H√ºgel vorne + Deko
        ctx.save();
        const hillGradFront = ctx.createLinearGradient(0, GROUND_Y - 40, 0, canvas.height);
        hillGradFront.addColorStop(0, "#78d86c");
        hillGradFront.addColorStop(1, "#46b45d");
        ctx.fillStyle = hillGradFront;
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y + 2);
        for (let x = 0; x <= canvas.width; x += 26) {
          const y = GROUND_Y + 2 - Math.sin((x + state.frame * 0.05) / 28) * 10;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.fill();

        // Kleine B√ºsche, Blumen, Mini-H√§uschen
        const decoOffset = (state.frame * 0.9) % 60;
        for (let i = 0; i < 18; i++) {
          const baseX = (i * 60) - decoOffset;
          const baseY = GROUND_Y - 10 + Math.sin((i * 11 + state.frame * 0.05) / 12) * 3;

          ctx.fillStyle = i % 3 === 0 ? "#4ad68b" : "#52c277";
          ctx.beginPath();
          ctx.ellipse(baseX, baseY, 10, 8, 0, 0, Math.PI * 2);
          ctx.fill();

          if (i % 4 === 0) {
            const flowerColors = ["#ff7ab8", "#ffd45c", "#9c8bff"];
            ctx.fillStyle = flowerColors[i % flowerColors.length];
            ctx.beginPath();
            ctx.arc(baseX + 8, baseY + 4, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#fffce7";
            ctx.beginPath();
            ctx.arc(baseX + 8, baseY + 4, 1.3, 0, Math.PI * 2);
            ctx.fill();
          }

          if (i % 7 === 0) {
            const houseX = baseX - 4;
            const houseY = baseY - 18;
            ctx.fillStyle = "#ffe6b8";
            ctx.fillRect(houseX, houseY, 16, 14);
            ctx.fillStyle = "#ff9ba5";
            ctx.beginPath();
            ctx.moveTo(houseX - 2, houseY);
            ctx.lineTo(houseX + 8, houseY - 8);
            ctx.lineTo(houseX + 18, houseY);
            ctx.fill();
            ctx.fillStyle = "#f1f5f9";
            ctx.fillRect(houseX + 5, houseY + 4, 5, 6);
          }
        }
        ctx.restore();
      }

      function drawCloud(x, y, r) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.arc(x + r * 0.9, y + 4, r * 0.7, 0, Math.PI * 2);
        ctx.arc(x - r * 0.9, y + 6, r * 0.6, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawGround() {
        ctx.save();
        ctx.strokeStyle = "rgba(40,72,99,0.9)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y + 0.5);
        ctx.lineTo(canvas.width, GROUND_Y + 0.5);
        ctx.stroke();

        const pathGrad = ctx.createLinearGradient(0, GROUND_Y + 4, 0, canvas.height);
        pathGrad.addColorStop(0, "#f9f1e3");
        pathGrad.addColorStop(1, "#f3dfba");
        ctx.fillStyle = pathGrad;
        ctx.fillRect(0, GROUND_Y + 4, canvas.width, canvas.height - (GROUND_Y + 4));

        ctx.fillStyle = "rgba(209,186,149,0.9)";
        for (let i = 0; i < 22; i++) {
          const px = (i * 46 - (state.frame * 1.4) % 46);
          const py = GROUND_Y + 14 + (i % 2) * 6;
          ctx.beginPath();
          ctx.ellipse(px, py, 6, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }
            function drawHumpty() {
        const centerX = humpty.x + humpty.width / 2;
        const centerY = humpty.y + humpty.height / 2;

        // kleines ‚ÄûWackeln‚Äú, wenn er l√§uft
        const bobOffset =
          state.running && !humpty.jumping && !state.gameOver && !state.win
            ? Math.sin(state.frame / 8) * 1.5
            : 0;

        ctx.save();
        ctx.translate(0, bobOffset);

        /* ---------- SPIEGELEI, wenn Game Over ---------- */
        if (state.gameOver) {
          const block = 4; // Pixelgr√∂√üe
          const eggCenterX = Math.round(centerX / block) * block;
          const eggBaseY = GROUND_Y + 4;

          // Eiwei√ü ‚Äì pixelig
          ctx.fillStyle = "#fefce8";
          const whitePattern = [
            "....XXXXXXX....",
            "..XXXXXXXXXXX..",
            ".XXXXXXXXXXXXX.",
            ".XXXXXXXXXXXXX.",
            ".XXXXXXXXXXXXX.",
            "..XXXXXXXXXXX..",
            "....XXXXXXX...."
          ];
          for (let row = 0; row < whitePattern.length; row++) {
            for (let col = 0; col < whitePattern[row].length; col++) {
              if (whitePattern[row][col] === "X") {
                const px = eggCenterX + (col - whitePattern[row].length / 2) * block;
                const py = eggBaseY + (row - whitePattern.length / 2) * block;
                ctx.fillRect(px, py, block, block);
              }
            }
          }

          // Eigelb ‚Äì pixelig
          ctx.fillStyle = "#fbbf24";
          const yolkPattern = [
            ".XXX.",
            "XXXXX",
            "XXXXX",
            "XXXXX",
            ".XXX."
          ];
          for (let row = 0; row < yolkPattern.length; row++) {
            for (let col = 0; col < yolkPattern[row].length; col++) {
              if (yolkPattern[row][col] === "X") {
                const px = eggCenterX + (col - yolkPattern[row].length / 2) * block;
                const py = eggBaseY - 2 * block + row * block;
                ctx.fillRect(px, py, block, block);
              }
            }
          }

          ctx.restore();
          return;
        }

        /* ---------- PIXEL-SPRITE HUMPTY ---------- */

        const block = 4; // ‚ÄûPixel‚Äú-Gr√∂√üe
        const spriteWidth = 12;
        const spriteHeight = 18;

        const baseX = Math.round(centerX - (spriteWidth * block) / 2);
        const baseY = Math.round(centerY - (spriteHeight * block) / 2);

        // Einfaches 12x18-Pattern
        // Zeichen:
        //  . = transparent
        //  O = Umrandung
        //  B = K√∂rper (Eiwei√ü)
        //  Y = bunter ‚ÄûG√ºrtel‚Äú
        //  E = Auge
        //  C = Wange
        //  L = Bein/Schuh
        const sprite = [
          "............",
          "....OOOO....",
          "...O BBB O..",
          "..O BBBBB O.",
          ".O BBBBBBB O",
          ".O BBBBBBB O",
          ".O BBBBBBB O",
          ".O BBBBBBB O",
          ".O BBBBBBB O",
          ".O BBBBBBB O",
          ".O BBBBBBB O",
          ".O BYYYYB O.",
          ".O BYYYYB O.",
          "..O BBBB O..",
          "...O    O...",
          "...L    L...",
          "...L    L...",
          "............"
        ];

        for (let row = 0; row < sprite.length; row++) {
          for (let col = 0; col < sprite[row].length; col++) {
            const ch = sprite[row][col];
            if (ch === ".") continue;

            let color = "#000000";
            if (ch === "O") color = "#111827";         // Outline
            if (ch === "B") color = "#fefce8";         // K√∂rper
            if (ch === "Y") color = "#fbbf24";         // G√ºrtel
            if (ch === "E") color = "#111827";         // (falls wir sp√§ter Augen als eigenes Zeichen nehmen)
            if (ch === "C") color = "#fb7185";         // Wange
            if (ch === "L") color = "#111827";         // Beine/Schuhe

            const px = baseX + col * block;
            const py = baseY + row * block;
            ctx.fillStyle = color;
            ctx.fillRect(px, py, block, block);
          }
        }

        // Extra: Augen & Wangen gezielt draufsetzen (damit sie sauber sitzen)
        ctx.fillStyle = "#111827"; // Augen
        ctx.fillRect(baseX + 4 * block, baseY + 4 * block, block, block);
        ctx.fillRect(baseX + 7 * block, baseY + 4 * block, block, block);

        ctx.fillStyle = "#fb7185"; // Wangen
        ctx.fillRect(baseX + 3 * block, baseY + 6 * block, block, block);
        ctx.fillRect(baseX + 8 * block, baseY + 6 * block, block, block);

        // kleiner Schatten unter Humpty
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        const shadowWidth = 8 * block;
        const shadowHeight = 2 * block;
        const shadowX = centerX - shadowWidth / 2;
        const shadowY = GROUND_Y + 6;
        ctx.fillRect(Math.round(shadowX), Math.round(shadowY), shadowWidth, shadowHeight);

        ctx.restore();
      }
      function drawObstacles() {
        ctx.save();
        obstacles.forEach(ob => {
          const grad = ctx.createLinearGradient(ob.x, ob.y, ob.x, ob.y + ob.height);
          grad.addColorStop(0, "#ff8ba7");
          grad.addColorStop(0.5, "#ffc857");
          grad.addColorStop(1, "#9b8cff");
          ctx.fillStyle = grad;

          ctx.strokeStyle = "rgba(88,28,135,0.8)";
          ctx.lineWidth = 2;

          ctx.beginPath();
          ctx.roundRect(ob.x, ob.y, ob.width, ob.height, 6);
          ctx.fill();
          ctx.stroke();

          ctx.strokeStyle = "rgba(255,255,255,0.45)";
          ctx.lineWidth = 1;
          const stepY = 10;
          for (let y = ob.y + 6; y < ob.y + ob.height; y += stepY) {
            ctx.beginPath();
            ctx.moveTo(ob.x + 3, y);
            ctx.lineTo(ob.x + ob.width - 3, y);
            ctx.stroke();
          }
        });
        ctx.restore();
      }

      function drawOverlay(text, subtext, accentColor) {
        ctx.save();
        ctx.fillStyle = "rgba(2,10,18,0.78)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.textAlign = "center";

        ctx.font = "bold 30px Poppins, system-ui, sans-serif";
        ctx.fillStyle = accentColor;
        ctx.fillText(text, canvas.width / 2, canvas.height / 2 - 10);

        ctx.font = "16px 'Nunito Sans', system-ui, sans-serif";
        ctx.fillStyle = "#e5edf6";
        ctx.fillText(subtext, canvas.width / 2, canvas.height / 2 + 18);

        ctx.font = "13px 'Nunito Sans', system-ui, sans-serif";
        ctx.fillStyle = "#9fb2c5";
        ctx.fillText("Leertaste oder Tippen f√ºr Neustart", canvas.width / 2, canvas.height / 2 + 42);

        ctx.restore();
      }

      function draw() {
        drawBackground();
        drawGround();
        drawObstacles();
        drawHumpty();

        if (state.gameOver) {
          drawOverlay("Oh nein ‚Äì jetzt bist du Spiegelei!", "Humpty ist von der Mauer gefallen.", "#fb7185");
        } else if (state.win) {
          drawOverlay("Geschafft ‚Äì 100.000 Punkte!", "Humpty Dumpty bleibt sicher auf der Mauer. ü•≥", "#b6de36");
        }
      }

      // Controls
      document.addEventListener("keydown", function (e) {
        if (e.code === "Space" || e.code === "ArrowUp") {
          e.preventDefault();
          jump();
        }
      });

      canvas.addEventListener("pointerdown", function () {
        jump();
      });

      restartBtn.addEventListener("click", function () {
        initGame();
      });

      // roundRect Polyfill
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
          if (w < 0) { x += w; w = -w; }
          if (h < 0) { y += h; h = -h; }
          if (typeof r === "number") {
            r = { tl: r, tr: r, br: r, bl: r };
          }
          this.beginPath();
          this.moveTo(x + r.tl, y);
          this.lineTo(x + w - r.tr, y);
          this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
          this.lineTo(x + w, y + h - r.br);
          this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
          this.lineTo(x + r.bl, y + h);
          this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
          this.lineTo(x, y + r.tl);
          this.quadraticCurveTo(x, y, x + r.tl, y);
          this.closePath();
        };
      }

      initGame();
      update();
    })();
  </script>
</body>
</html>

